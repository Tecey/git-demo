git help config
	ви можете отримати допомогу у довіднику для команди git config або інші команди

git config -h
	можете отримати стислішу
	версію за допомогою опцій -h чи --help

/	/	/	/	/	/	/	/	/	/	/	/	/	/

	git config --global user.name "Vadym Nechyporenko"
	git config --global user.email "tecey1@gmail.com"

	git config --global user.email
	tecey1@gmail.com

	git config --global user.name
	Vadym Nechyporenko

	git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe'
	> -multiInst -nosession"


/	/	/	/	/	/	/	/	/	/	/	/	/	/

pwd
	показує діючий каталог на зараз
	
git config --list
	подивитися на свої налаштування
	
git init
	Це створить новий підкаталог .git, який містить всі необхідні файли вашого
	репозиторія — скелет Git-репозиторія

cd /F/IT/EPAM_навч/data/temp/
	перехід в гілку (master за замовченням)

cd git-demo/
	перехід в гілку main


git clone https://github.com/Tecey/git-demo
	створює папку на гітхабу

git clone 
	автоматично налаштовує вашу локальну гілку master слідкувати за
	віддаленою гілкою master (хоча вона може називатись і по іншому) на віддаленому
	сервері, з якого ви зробили клон


git remote -v
	Щоб побачити, які віддалені сервера ви налаштували
	опцію -v, яка покаже вам посилання, які Git зберігає та
	використовує при читанні та записі до цього сховища


*	*	*	*	*	*	*	*	*
***
git status
	виясняє зміни відстежуваної папки
	
	git diff
	аналог статус але більш детально (показує внесені зміни)

***
git add git_command.txt
	(проіндексувати) добавляє відстеження файла
git add *
	всі проіндиксує
	
git rm 		song.txt.txt.bak
	видалити його з індексу
	-видаляє файл з вашої робочої директорії, щоб наступного разу він
	не відображався неконтрольованим
	
***
git commit -m "add new fail"
	добаляє + коментує зміни
git commit -m "add first half of my favorite song"
***
git push 		git_command.txt
	відправляє до гітхабу (на сервер з якого зробив клон)

	
	
git fetch
	отримати від сервера інформацію (з сервера з якого зробив клон)
	-лише завантажує дані до вашого локального сховища — вона автоматично не зливає їх з
	вашою роботою, та не змінює вашу поточну працю. Вам буде потрібно вручну її
	злити, коли ви будете готов

*	*	*	*	*	*	*	*	*


git log
	Перегляд історії комітів
	
git log --pretty=oneline
git log --pretty=format:"%h %s" -graph
	гарна візуалізація інформації

git log master..experiment
	Скажімо, ви хочете дізнатися, що є у вашій гілці experiment такого, що досі не
	злито до вашої гілки master. Ви можете попросити Git показати журнал саме
	таких комітів за допомогою master..experiment - це означає “усі коміти, що є
	досяжними з experiment, проте не є досяжними з master.” Задля стислості та
	зрозумілості в подальших прикладах замість справжнього виводу команди git log
	для позначення комітів використовуються літери, проте у правильному порядку

	
git pull
	зазвичай дістає дані з серверу, з якого ви зробили клон, та намагається злити її з кодом, над яким ви зараз працюєте.
	
git gui&
	викликає менеджер git gui
	переважно є інструментом для доопрацювання комітів

gitk&
	викликає менеджер gitk&
	це графічний переглядач історії

git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
	Таке трапляється скрізь. Хтось випадково зберігає величезний двійковий файл
	бездумним git add ., та ви бажаєте видалити його скрізь

git show
	можете побачити дані теґу та коміт, на який він вказує

git show -s --pretty=raw b2b84
	Другий спосіб позначати коміти — за допомогою легких позначок. Це просто хеш
	коміту збережений у файлі — ніякої іншої інформації не зберігається. Щоб створити
	легкий теґ, не додавайте жодної з опцій -a, -s та -m, вкажіть лише назву теґу

git ls-tree 629eb
git show add54
	якщо ви включите інструкції в повідомлення теґу, то виконання git show <теґ> дозволить вам надати користувачу більш детальні інструкції щодо перевірки теґу



git checkout -- file.txt
	git checkout -- <файл> небезпечна. Будь-які
	зроблені зміни зникли — Git просто скопіював інший файл поверх
	них. Ніколи не використовуйте цю команду, якщо у вас нема
	абсолютної впевненості, що цей файл вам не потрібен

git checkout .
	щоб скасувати зміни у вашій робочій директорії
	на всі файли
	
git clean -xdf
	можливо ви бажаєте не ховати якісь зміни до файлів у робочій
	директорії, а просто позбутися їх
	

git reset -- file.txt
	Команда git reset і справді може бути небезпечною, особливо
разом з опцією --hard. Втім, в описаному вище випадку, файл
у робочій теці не змінюється жодним чином, тож вона
відносно безпечна.

git reset HEAD^^ (HEAD~2)
git commit --amend -m "commit message"

git revert <sha1>
	git revert по суті є git cherry-pick навиворіт. Вона створює новий коміт,
	який застосовує точну протилежність впроваджених цільовим комітом змін, по суті
	скасовуючи чи вивертаючи їх
	
	

/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/
	***	gitignor	***

.gitignore

# ігнорувати всі файли .log
*.log

# проте відстежувати файл error.log хоч ми й ігноруємо .log файли вище
!error.log

# Ігнорувати файл TODO тільки в поточній теці, не в інших теках subdir/TODO
/TODO

# Ігнорувати усі файли в теці build/
build/

# Ігнорувати doc/notes.txt, проте не doc/server/arch.txt
doc/*.txt

# Ігнорувати усі .pdf файли в теці doc/ та всіх її підтеках
doc/**/*.pdf

/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/


git branch (назва)
	створюэ нову гілку з (назвою)

git checkout -b iss53
	створення та перехід в нову гілку "iss53"

git checkout master
	перехід в гілку 'master'

git merge hotfix
	злитя "hotfix" в 'master' бо тут зараз знаходимось

git branch -d hotfix
	видаляє гілку "hotfix" (3a0874c).


git merge --abort
	намагається повернутися до стану, в якому ви були до початку зливання

git checkout --Xours "або" --Xtheirs
	при конфлікті зливання втоматично вибере якусь сторону


git revert 09Fe472
	створити новий коміт, що скасовує всі зміни з існуючого коміту
	Ми використовуємо це в Вивертання коміту, щоб скасувати коміт злиття
	
git	rebase 
	перебазування гілки на іншу
	Не перебазовуйте коміти, що існують в інших репозиторіях

cherry-pick
	перебазуванням та висмикування
	Інші супроводжувачі надають перевагу перебазуванню та висмикуванню нової
	роботи поверху їхньої гілки master, замість зливання до неї, задля якомога
	лінійнішої історії.
	

git tag ver1
	теги версія 1
		
git tag --list
	якщо ви використовуєте шаблон зі спеціальними
	символами, то використання -l чи --list є обовʼязковим
	
git push --tags
	явно надсилати теґи на спільний сервер після створення
	агато теґів, та ви хочете надіслати їх разом, ви також можете
	використати опцію --tags команди git push
	
git checkout ver1
	Якщо ви бажаєте переглянути версії файлів, на які вказує теґ, виконайте git
	checkout
	
	
/	/	/Stashing - схованка, сховище/	/	/
git stash зберігає лише змінені й індексовані супроводжувані файли

git stash save "description"
	зберегти робочий каталог
	Ховання (stashing) бере чорновий стан вашої робочої директорії — тобто ваші змінені
	супроводжувані файли та індексовані зміни — та зберігає їх у стеку незавершених
	змін, які ви можете знову використати будь-коли (і навіть на іншій гілці).

git stash list
	переглянути стек сховище
	Щоб побачити збереженні ховання, використовуйте	

git stash pop
	перенос назад і видалення з сховища стеку
	щоб застосувати ховання та відразу
	видалити його зі стека

git stash apply
	перенос назад і залишити в сховищі
	Якщо ви бажаєте використати одне з попередніх ховань, то
	вам доведеться задати його назву, наприклад: git stash apply stash@{2}.

git stash drop
	видалити та очистити
	Щоб видалити його, ви можете виконати git stash drop з
	назвою ховання
	
/	/	/Remote - віддалені/	/	/

git remot
	Щоб побачити, які віддалені сервера ви налаштували, ви можете виконати команду

git remote -v
	Ви також можете дати опцію -v, яка покаже вам посилання, які Git зберігає та
	використовує при читанні та записі до цього сховища

git remote remove origin


git remote add <name> <url>
git remote add origin git@github.com:user/repo.git
	Щоб додати нове віддалене Git сховище під заданим ім’ям, на яке ви можете
	легко посилатись, виконайте git remote add <ім’я> <посилання на репозиторій>:
	
git remote show <name>
	для детальної інформації про віддалені гілки.
	
	
git blame
	Команда git blame анотує рядки будь-якого файлу комітами, які востання змінювали
	кожен рядок файлу, а також автором цього коміту. Це корисно, щоб дізнатися, до
	кого варто звернутися, щоб дізнатися більше про окрему частину вашого коду
	-Більш того, використовується опція -L щоб обмежити вивід анотації до рядків з 69
	до 82:
	-з опцією -C, ви можете побачити, звідки зʼявились секції коду
	
git bisect
	bisect виконує двійковий пошук у вашій історії комітів, щоб
	допомогти вам визначити якомога швидше, який коміт спричинив проблему
git bisect start
git bisect bad
git bisect good <гарний коміт>

git last
	Тепер ви легко можете побачити останній коміт
	
git rerere
	Назва походить від “використовуй
	записані розвʼязання” (reuse recorded resolution) та, як зрозуміло з назви, дозволяє
	вам попросити Git запамʼятати, як ви розвʼязали конфлікт шматків (hunk), щоб
	наступного разу Git міг автоматично розвʼязати такий самий конфлікт для вас
	
git config --global rerere.enabled true
	Щоб увімкнути функціональність rerere, треба просто виконати це налаштування
	конфігурації
	
git submodule add https://github.com/chaconinc/DbConnector
	Почнімо з додавання існуючого репозиторія Git як підмодуля репозиторія, над
	яким ми працюємо. Щоб додати новий підмодуль, використайте команду git
	submodule add з абсолютним чи відносним URL проекту
	
	
	Директорію DbConnector створено, проте вона порожня. Ви маєте виконати дві
	команди: 
git submodule init 
	щоб проініціалізувати ваш файл локальною конфігурації, та 
git submodule update
	щоб отримати всі дані з того проекту та перейти до відповідного коміту, який вказано у вашому головному проекті
	
git restore song.txt.txt
	відновлює видалений файл
	