git config --global user.name "Vadym Nechyporenko"
git config --global user.email "tecey1@gmail.com"

git config --global user.email
tecey1@gmail.com

git config --global user.name
Vadym Nechyporenko

pwd

git config --list

git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe'
> -multiInst -nosession"

git init
	Це створить новий підкаталог .git, який містить всі необхідні файли вашого
	репозиторія — скелет Git-репозиторія

cd /F/IT/EPAM_навч/data/temp/
	перехід в гілку (master за замовченням)

cd git-demo/
	перехід в гілку main


git clone https://github.com/Tecey/git-demo
	створює папку на гітхабу

git clone 
	автоматично налаштовує вашу локальну гілку master слідкувати за
	віддаленою гілкою master (хоча вона може називатись і по іншому) на віддаленому
	сервері, з якого ви зробили клон


git remote -v
	Щоб побачити, які віддалені сервера ви налаштували
	опцію -v, яка покаже вам посилання, які Git зберігає та
	використовує при читанні та записі до цього сховища


*	*	*	*	*	*	*	*	*
***
git status
	виясняє зміни відстежуваної папки
	
git diff
	аналог статус але більш детально

***
git add git_command.txt
	(проіндексувати) добавляє відстеження файла

***
git commit -m "add new fail"
	добаляє + коментує зміни

***
git push git_command.txt
	відправляє до гітхабу (на сервер з якого зробив клон)

*	*	*	*	*	*	*	*	*


git log
	Перегляд історії комітів
	
git pull
	зазвичай дістає дані з
	серверу, з якого ви зробили клон, та намагається злити її з кодом, над яким ви
	зараз працюєте.
	
git gui&
	викликає менеджер git gui
	переважно є інструментом для доопрацювання комітів

gitk&
	викликає менеджер gitk&
	це графічний переглядач історії

????????

git show -s --pretty=raw b2b84
git ls-tree 629eb
git show add54

git checkout -- file.txt
git checkout .
	на всі файли
git clean -xdf

git reset -- file.txt
	Команда git reset і справді може бути небезпечною, особливо
разом з опцією --hard. Втім, в описаному вище випадку, файл
у робочій теці не змінюється жодним чином, тож вона
відносно безпечна.

git reset HEAD^^ (HEAD~2)
git commit --amend -m "commit message"

git revert <sha1>

/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/
	***	gitignor	***

.gitignore

# ігнорувати всі файли .log
*.log

# проте відстежувати файл error.log хоч ми й ігноруємо .log файли вище
!error.log

# Ігнорувати файл TODO тільки в поточній теці, не в інших теках subdir/TODO
/TODO

# Ігнорувати усі файли в теці build/
build/

# Ігнорувати doc/notes.txt, проте не doc/server/arch.txt
doc/*.txt

# Ігнорувати усі .pdf файли в теці doc/ та всіх її підтеках
doc/**/*.pdf

/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/	/


git branch (назва)
	створюэ нову гілку з (назвою)

git checkout -b iss53
	створення та перехід в нову гілку "iss53"

git checkout master
	перехід в гілку 'master'

git merge hotfix
	злитя "hotfix" в 'master' бо тут зараз знаходимось

git branch -d hotfix
	видаляє гілку "hotfix" (3a0874c).


git merge --abort
	намагається повернутися до стану, в якому ви були до початку зливання

git checkout --Xours "або" --Xtheirs
	при конфлікті зливання втоматично вибере якусь сторону


git revert 09Fe472
	створити новий коміт, що скасовує всі зміни з існуючого коміту
	Ми використовуємо це в Вивертання коміту, щоб скасувати коміт злиття
	
git	rebase 
	перебазування гілки на іншу
	Не перебазовуйте коміти, що існують в інших репозиторіях

cherry-pick
	перебазуванням та висмикування
	Інші супроводжувачі надають перевагу перебазуванню та висмикуванню нової
	роботи поверху їхньої гілки master, замість зливання до неї, задля якомога
	лінійнішої історії.
	
